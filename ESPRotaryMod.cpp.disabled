/////////////////////////////////////////////////////////////////
/*
  ESP8266/Arduino Library for reading rotary encoder values.
  Copyright 2017-2020 Lennart Hennigs.
*/
/////////////////////////////////////////////////////////////////

#include "ESPRotaryMod.h"
#include "Adafruit_MCP23017.h"

/////////////////////////////////////////////////////////////////

ESPRotaryMod::ESPRotaryMod(Adafruit_MCP23017 mcp, int pin1, int pin2, int steps_per_click /* = 1 */, int lower_bound /* = -32768 */, int upper_bound /* = 32768 */) {
  this->pin1 = pin1;
  this->pin2 = pin2;
  this->lower_bound = (lower_bound < upper_bound) ? lower_bound : upper_bound;
  this->upper_bound = (lower_bound < upper_bound) ? upper_bound: lower_bound;
  this->mcp = mcp;
  setStepsPerClick(steps_per_click);

  this->mcp.pinMode(pin1, INPUT_PULLUP);
  this->mcp.pinMode(pin2, INPUT_PULLUP);

  loop();
  resetPosition();
  last_read_ms = 0;
}

/////////////////////////////////////////////////////////////////

void ESPRotaryMod::setChangedHandler(CallbackFunction f) {
  change_cb = f;
}

/////////////////////////////////////////////////////////////////

void ESPRotaryMod::setRightRotationHandler(CallbackFunction f) {
  right_cb = f;
}

/////////////////////////////////////////////////////////////////

void ESPRotaryMod::setLeftRotationHandler(CallbackFunction f) {
  left_cb = f;
}

/////////////////////////////////////////////////////////////////

void ESPRotaryMod::resetPosition(int p /* = 0 */) {
  if (p > upper_bound) {
    last_position = upper_bound * steps_per_click;
  } else {
    last_position = (lower_bound > p) ? lower_bound * steps_per_click : p;
  }
  position = last_position * steps_per_click;
  direction = 0;
}

/////////////////////////////////////////////////////////////////

void ESPRotaryMod::setStepsPerClick(int steps) {  
  steps_per_click = (steps < 1) ? 1 : steps;
}

/////////////////////////////////////////////////////////////////

int ESPRotaryMod::getStepsPerClick() {
  return steps_per_click;
}

/////////////////////////////////////////////////////////////////

byte ESPRotaryMod::getDirection() {
  return direction;
}

/////////////////////////////////////////////////////////////////

String ESPRotaryMod::directionToString(byte direction) {
  if (direction == RE_LEFT) {
    return "LEFT";
  } else if (direction == RE_RIGHT) {
    return "RIGHT";
    }
}

/////////////////////////////////////////////////////////////////

int ESPRotaryMod::getPosition() {
  return position / steps_per_click;
}

/////////////////////////////////////////////////////////////////

void ESPRotaryMod::loop() {
  int s = state & 3;
  if (this->mcp.digitalRead(pin1)) s |= 4;
  if (this->mcp.digitalRead(pin2)) s |= 8;

  switch (s) {
    case 0: case 5: case 10: case 15:
      break;
    case 1: case 7: case 8: case 14:
        position++; break;
    case 2: case 4: case 11: case 13:
      position--; break;
    case 3: case 12:
      position += 2; break;
    default:
      position -= 2; break;
  }
  state = (s >> 2);
  
  if (getPosition() >= lower_bound && getPosition() <= upper_bound) {
    if (position != last_position) {
      if (abs(position - last_position) >= steps_per_click) {
        if (position > last_position) {
          direction = RE_RIGHT;
          if (right_cb != NULL) right_cb (*this);
        } else {
          direction = RE_LEFT;
          if (left_cb != NULL) left_cb (*this);
        }
        last_position = position;      
        if (change_cb != NULL) change_cb (*this);
      }
    }
  } else position = last_position;
}

/////////////////////////////////////////////////////////////////
